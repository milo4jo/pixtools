{
  "slug": "building-local-first",
  "date": "2026-02-10",
  "title": "Building a Local-First AI Developer Tool",
  "description": "The technical decisions behind ContextKit and what I learned",
  "tags": ["architecture", "local-first", "engineering"],
  "content": "There's a moment every developer knows: you're deep in a codebase, trying to explain something to an AI assistant, and you realize you've spent more time finding the right files to paste than actually solving the problem.\n\nThis is the context problem. And it's why I built ContextKit.\n\n## Why Local-First?\n\nBefore writing any code, I had to make a fundamental decision: where does the computation happen?\n\n### The Cloud Option\n\nMost dev tools go cloud-first. It's easier to build, easier to monetize, and you control the infrastructure. But for a context tool, cloud means:\n\n- **Privacy concerns** — Your code leaves your machine\n- **Latency** — Every query hits a server\n- **Cost** — API calls add up\n- **Offline? Forget it**\n\n### The Local-First Choice\n\nContextKit runs entirely on your machine. Your code never leaves. The tradeoffs:\n\n- **Harder to build** — No server means no shortcuts\n- **Harder to monetize** — Can't easily gate features\n- **Better privacy** — Code stays local\n- **Better speed** — No network roundtrip\n- **Works offline** — Index your code on a plane\n\nFor a tool that touches your entire codebase, local-first was the only choice that made sense.\n\n## The Architecture\n\nContextKit has three main components:\n\n```\n┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│   Indexer   │ --> │   SQLite    │ --> │  Selector   │\n│  (Chunking) │     │  (Storage)  │     │  (Search)   │\n└─────────────┘     └─────────────┘     └─────────────┘\n```\n\n### Smart Chunking\n\nNot all code is equal. A 500-line file shouldn't be one chunk. ContextKit uses AST-aware chunking:\n\n- **Functions** stay together\n- **Classes** include their methods\n- **Imports** are tracked for dependency resolution\n\n### SQLite: The Unsung Hero\n\nWhy SQLite instead of a \"real\" database?\n\n- **Zero setup** — No Docker, no servers\n- **Single file** — Easy to backup, delete, move\n- **Fast enough** — We're not doing petabyte analytics\n\n### Local Embeddings\n\nEmbeddings convert text into vectors that capture meaning. Most require API calls.\n\nContextKit runs models locally with `@xenova/transformers`. First run downloads the model (~50MB). After that, it's instant and offline.\n\n## What I Learned\n\n### 1. Start Simple, Stay Simple\n\nMy first design had plugins, hooks, custom parsers, and a DSL. None of it shipped.\n\nThe current version has one config file, one database, and a few commands. That's it.\n\n### 2. CLI First, GUI Later\n\nBuilding a CLI forced me to think about the core value. No buttons to hide behind.\n\nThe VS Code extension came later, wrapping the CLI. Same core, different interface.\n\n### 3. Developer Experience is Product\n\nError messages matter. Progress indicators matter. The `contextkit doctor` command exists because debugging should be easy.\n\n## Try It\n\n```bash\nnpm install -g @milo4jo/contextkit\n\ncd your-project\ncontextkit init\ncontextkit source add ./src\ncontextkit index\ncontextkit select \"how does authentication work\"\n```\n\nLocal-first isn't just a technical choice. It's a philosophy: your tools should work for you, on your machine, under your control."
}
